Question 1. Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;

Answer: x should have uintptr_t type, because T* is a virtual address and by just assigning values it is not possible to convert virtual address to physical.


Question 2. What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible.

Answer.
******************************************************************************
* Entry * Base Virtual Address * Points to (logically)                       *
******************************************************************************
* 1023  * 0xffc00000           * Page table for top 4MB of phys memory       *
******************************************************************************
* 1022  * 0xff800000           * ?                                           *
******************************************************************************
* ...   * ...                  * ...                                         *
******************************************************************************
* 960   * 0xf0000000           * Kernel stack top (KSTACKTOP)                *
******************************************************************************
* 959   * 0xefff8000           * Start of the bootstack (KSTACKTOP-KSTKSIZE) *
******************************************************************************
* 958   * 0xefbf8000           * ?                                           *
******************************************************************************
* 957   * 0xef400000           * Virtual page table (UVPT)                   *
******************************************************************************
* 956   * 0xef000000           * Read only pages for user (UPAGES)           *
******************************************************************************
* 955   * 0xefc00000           * Empty                                       *
******************************************************************************
* ...   * ...                  * ...                                         *
******************************************************************************
* 2     * 0x00800000           * Empty                                       *
******************************************************************************
* 1     * 0x00400000           * Empty                                       *
******************************************************************************
* 0     * 0x00000000           * Empty                                       *
******************************************************************************


Question 3. (From Lecture 3) We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

Answer: Because user permission bit (PTE_U) is not set.


Question 4. What is the maximum amount of physical memory that this operating system can support? Why?

Answer: In inc/memlayout.h it is shown that remapped physical memory is from 0xf0000000 to 4 GB (0x100000000), and (0x100000000 - 0xf0000000) / 0x100000 = 0x100, which is equal to 256 in decimal, so the maximal amount of physical memory that this operation system can support is 256 MB.


Question 5. How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

Answer: Each page takes up 4096 bytes, and there are 1024 pages, so 4096 * 1024 = 4194304 bytes, which is 4 MB.


Question 6. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

Answer: Transition to running at an EIP above KERNBASE happens at this point in kern/entry.S:
	# Now paging is enabled, but we're still running at a low EIP
	# (why is this okay?).  Jump up above KERNBASE before entering
	# C code.
	mov	$relocated, %eax
	jmp	*%eax
We can continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE because we map the same [0; 4MB) physical address as [KERNBASE, KERNBASE+4MB) maps.
